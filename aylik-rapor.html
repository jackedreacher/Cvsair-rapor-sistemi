<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>AylÄ±k Raporlar â€¢ CVS Air</title>
  <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
  <script>
    (function(){
      try {
        const AUTH_KEY='auth_v1';
        const ALLOWED=['Cvsadmin','yunus','hakan','gokhan'];
        const auth = JSON.parse(localStorage.getItem(AUTH_KEY)||'null');
        const ok = auth && Array.isArray(ALLOWED) && ALLOWED.includes(auth.u) && typeof auth.t==='string' && auth.t.length>0;
        if(!ok){ window.location.href='login.html'; }
      } catch(e){ window.location.href='login.html'; }
    })();
  </script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1d29; color: #ffffff; }
    .container { max-width: 1200px; margin: 0 auto; padding: 24px; }
    .header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
    .title { font-size: 24px; font-weight: 700; }
    .date { color: #a6adc8; font-size: 14px; }
    .status { background: #252836; border: 1px solid #313244; padding: 12px 16px; border-radius: 12px; margin-bottom: 16px; }
    .grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; }
    .card { background: #252836; border: 1px solid #313244; border-radius: 16px; padding: 16px; }
    .card h3 { font-size: 16px; margin-bottom: 8px; color: #cdd6f4; }
    .metric { display: flex; align-items: baseline; gap: 8px; margin-bottom: 6px; }
    .metric .label { color: #a6adc8; font-size: 13px; }
    .metric .value { font-size: 20px; font-weight: 700; }
    .delta.up { color: #8bd5ca; }
    .delta.down { color: #f38ba8; }
    .chart { height: 360px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #313244; padding: 10px; text-align: left; }
    th { color: #a6adc8; font-weight: 600; }
    tr:hover td { background: #1f2230; }
    .note { color: #a6adc8; font-size: 12px; margin-top: 8px; }
    @media (max-width: 768px) { .grid { grid-template-columns: 1fr; } .chart { height: 280px; } }
  </style>
  <script>
    // Plotly gÃ¼venlik aÄŸÄ±: CDN dÃ¼ÅŸerse alternatifleri dene ve stub ekle
    (function ensurePlotly(){
      if (typeof window !== 'undefined' && typeof window.Plotly === 'undefined') {
        const sources = [
          'https://cdn.plot.ly/plotly-2.26.0.min.js',
          'https://cdn.jsdelivr.net/npm/plotly.js-dist-min@2.26.0/plotly.min.js',
          'https://unpkg.com/plotly.js-dist-min@2.26.0/plotly.min.js'
        ];
        let i = 0;
        const tryNext = () => {
          if (i >= sources.length) return;
          const s = document.createElement('script');
          s.src = sources[i++]; s.async = true;
          s.onload = () => console.log('Plotly loaded:', s.src);
          s.onerror = () => { console.warn('Plotly load failed:', s.src); tryNext(); };
          document.head.appendChild(s);
        };
        tryNext();
        setTimeout(() => { if (typeof window.Plotly === 'undefined') { window.Plotly = { newPlot: () => {} }; } }, 3000);
      }
    })();
  </script>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="title">ðŸ“ˆ AylÄ±k Raporlar</div>
      <div class="date" id="headerNow"></div>
    </div>
    <div class="status" id="dataStatus">ðŸ“¥ Veriler yÃ¼kleniyor...</div>

    <div class="grid">
      <div class="card" id="dailyCard">
        <h3>GÃ¼nlÃ¼k KarÅŸÄ±laÅŸtÄ±rma (USD/EUR)</h3>
        <div class="metric"><span class="label">Son GÃ¼n (USD):</span><span class="value" id="dailyLatestUSD">â€”</span></div>
        <div class="metric"><span class="label">Ã–nceki GÃ¼n (USD):</span><span class="value" id="dailyPrevUSD">â€”</span></div>
        <div class="metric"><span class="label">DeÄŸiÅŸim:</span><span class="value" id="dailyDeltaUSD">â€”</span> <span class="delta" id="dailyDeltaUSDPct">â€”</span></div>
        <div class="metric"><span class="label">Son GÃ¼n (EUR):</span><span class="value" id="dailyLatestEUR">â€”</span></div>
        <div class="metric"><span class="label">Ã–nceki GÃ¼n (EUR):</span><span class="value" id="dailyPrevEUR">â€”</span></div>
        <div class="metric"><span class="label">DeÄŸiÅŸim:</span><span class="value" id="dailyDeltaEUR">â€”</span> <span class="delta" id="dailyDeltaEURPct">â€”</span></div>
        <div class="note">TL toplamlarÄ± aylÄ±k tabloda ve grafikte gÃ¶sterilir.</div>
      </div>
      <div class="card" id="monthlyCard">
        <h3>AylÄ±k KarÅŸÄ±laÅŸtÄ±rma (USD/EUR)</h3>
        <div class="metric"><span class="label">Bu Ay (USD):</span><span class="value" id="monthNowUSD">â€”</span></div>
        <div class="metric"><span class="label">GeÃ§en Ay (USD):</span><span class="value" id="monthPrevUSD">â€”</span></div>
        <div class="metric"><span class="label">DeÄŸiÅŸim:</span><span class="value" id="monthDeltaUSD">â€”</span> <span class="delta" id="monthDeltaUSDPct">â€”</span></div>
        <div class="metric"><span class="label">Bu Ay (EUR):</span><span class="value" id="monthNowEUR">â€”</span></div>
        <div class="metric"><span class="label">GeÃ§en Ay (EUR):</span><span class="value" id="monthPrevEUR">â€”</span></div>
        <div class="metric"><span class="label">DeÄŸiÅŸim:</span><span class="value" id="monthDeltaEUR">â€”</span> <span class="delta" id="monthDeltaEURPct">â€”</span></div>
        <div class="note">TL MoM grafiÄŸi aÅŸaÄŸÄ±da ayrÄ± izlenir.</div>
      </div>
    </div>

    <div class="card" style="margin-top:16px;">
      <h3>AylÄ±k Toplamlar (TL)</h3>
      <div id="monthlyChart" class="chart"></div>
    </div>

    <div class="card" style="margin-top:16px;">
      <h3>AylÄ±k Detay Tablosu</h3>
      <table>
        <thead>
          <tr>
            <th>Ay</th>
            <th>SipariÅŸ Adedi</th>
            <th>TL Toplam</th>
            <th>USD Toplam</th>
            <th>EUR Toplam</th>
            <th>MoM (TL %)</th>
          </tr>
        </thead>
        <tbody id="monthlyTableBody"></tbody>
      </table>
      <div class="note">Toplamlar dÃ¶viz bazÄ±nda ayrÄ± tutulur; kur dÃ¶nÃ¼ÅŸÃ¼mÃ¼ uygulanmaz.</div>
    </div>
  </div>

  <script>
    // Header saat
    function startHeaderClock(){
      const el = document.getElementById('headerNow');
      const fmt = () => new Date().toLocaleString('tr-TR', {year:'numeric', month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false}).replace(',', '');
      el.textContent = `Åžu an: ${fmt()}`;
      setInterval(() => { el.textContent = `Åžu an: ${fmt()}`; }, 1000);
    }

    // Fetch ve cache yardÄ±mcÄ±larÄ±
    async function fetchWithTimeout(url, options = {}, timeoutMs = 15000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeoutMs);
      try { return await fetch(url, { ...options, signal: controller.signal, cache: 'no-store' }); }
      finally { clearTimeout(id); }
    }
    async function retryFetch(url, options = {}, retries = 2, timeoutMs = 15000) {
      let attempt = 0, lastErr;
      while (attempt <= retries) {
        try { return await fetchWithTimeout(url, options, timeoutMs); }
        catch (err) { lastErr = err; attempt++; await new Promise(r => setTimeout(r, 400 * attempt)); }
      }
      throw lastErr;
    }

    const ORDERS_CACHE_KEY = 'ordersCache_v1';
    function readOrdersCache(){
      try { const raw = localStorage.getItem(ORDERS_CACHE_KEY); if (!raw) return null; const parsed = JSON.parse(raw); return Array.isArray(parsed.data) ? parsed.data : null; }
      catch { return null; }
    }
    function writeOrdersCache(dataArray){
      try { localStorage.setItem(ORDERS_CACHE_KEY, JSON.stringify({ ts: Date.now(), data: dataArray })); }
      catch {}
    }

    // IndexedDB kalÄ±cÄ± cache
    const IDB_NAME = 'cvsair-db';
    const IDB_VERSION = 2; // gÃ¼nlÃ¼k snapshotlar iÃ§in v2
    const IDB_STORE_ORDERS = 'orders';
    const IDB_STORE_DAYS = 'days';
    function idbOpen(){
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(IDB_NAME, IDB_VERSION);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(IDB_STORE_ORDERS)) db.createObjectStore(IDB_STORE_ORDERS, { keyPath: 'key' });
          if (!db.objectStoreNames.contains(IDB_STORE_DAYS)) db.createObjectStore(IDB_STORE_DAYS, { keyPath: 'key' });
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }
    async function idbGetLatest(){
      try { const db = await idbOpen(); return await new Promise((resolve, reject) => { const tx = db.transaction(IDB_STORE_ORDERS, 'readonly'); const st = tx.objectStore(IDB_STORE_ORDERS); const req = st.get('latest'); req.onsuccess = () => resolve(req.result || null); req.onerror = () => reject(req.error); }); }
      catch(e){ console.warn('IDB read error', e); return null; }
    }
    async function idbPutLatest(data){
      try { const db = await idbOpen(); return await new Promise((resolve, reject) => { const tx = db.transaction(IDB_STORE_ORDERS, 'readwrite'); const st = tx.objectStore(IDB_STORE_ORDERS); const payload = { key:'latest', data, updatedAt: Date.now() }; const req = st.put(payload); req.onsuccess = () => resolve(true); req.onerror = () => reject(req.error); }); }
      catch(e){ console.warn('IDB write error', e); return false; }
    }
    async function idbGetDay(dayKey){
      try { const db = await idbOpen(); return await new Promise((resolve, reject) => { const tx = db.transaction(IDB_STORE_DAYS, 'readonly'); const st = tx.objectStore(IDB_STORE_DAYS); const req = st.get(dayKey); req.onsuccess = () => resolve(req.result || null); req.onerror = () => reject(req.error); }); }
      catch(e){ console.warn('IDB read error (days)', e); return null; }
    }
    async function idbPutDay(dayKey, snapshot){
      try { const db = await idbOpen(); return await new Promise((resolve, reject) => { const tx = db.transaction(IDB_STORE_DAYS, 'readwrite'); const st = tx.objectStore(IDB_STORE_DAYS); const payload = { key: dayKey, ...snapshot, updatedAt: Date.now() }; const req = st.put(payload); req.onsuccess = () => resolve(true); req.onerror = () => reject(req.error); }); }
      catch(e){ console.warn('IDB write error (days)', e); return false; }
    }
    async function ensurePersistence(){
      if (navigator.storage && navigator.storage.persist) {
        try { const persisted = await navigator.storage.persisted(); if (!persisted) { await navigator.storage.persist().catch(()=>{}); } } catch {}
      }
    }

    // YardÄ±mcÄ±lar
    const fmtMoney = (n) => (typeof n === 'number' ? n : 0).toLocaleString('tr-TR', { minimumFractionDigits: 0 });
    const pad2 = (n) => String(n).padStart(2, '0');
    // DetaylÄ±-rapor mantÄ±ÄŸÄ±yla saÄŸlam tarih parse (ISO, dd.mm.yyyy, Excel seri)
    function parseDate(v){
      if (!v) return null;
      if (v instanceof Date) return v;
      if (typeof v === 'number') {
        if (v > 25569 && v < 100000000) { // Excel seri
          return new Date((v - 25569) * 86400 * 1000);
        }
        const dnum = new Date(v);
        return isNaN(dnum) ? null : dnum;
      }
      const s = String(v).trim();
      // Safari uyumu: 'YYYY-MM-DDTHH:mm:ss' (timezone yok) yerel olarak parse et
      const m = s.match(/^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})$/);
      if (m) {
        const y = parseInt(m[1],10), mo = parseInt(m[2],10)-1, d = parseInt(m[3],10), hh = parseInt(m[4],10), mm = parseInt(m[5],10), ss = parseInt(m[6],10);
        const dd = new Date(y, mo, d, hh, mm, ss);
        return isNaN(dd) ? null : dd;
      }
      const iso = new Date(s);
      if (!isNaN(iso.getTime())) return iso;
      const parts = s.split('.');
      if (parts.length === 3) {
        const d = parseInt(parts[0], 10);
        const m2 = parseInt(parts[1], 10) - 1;
        const y2 = parseInt(parts[2], 10);
        const dd2 = new Date(y2, m2, d);
        return isNaN(dd2) ? null : dd2;
      }
      return null;
    }
    function ymd(d){ return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; }
    function ym(d){ return `${d.getFullYear()}-${pad2(d.getMonth()+1)}`; }
    function addDays(d, days){ const nd = new Date(d); nd.setDate(nd.getDate()+days); return nd; }

    function num(v){
      if (typeof v === 'number') return v;
      const s = String(v).replace(/"/g, '').replace(/,/g, '').trim();
      const n = parseFloat(s);
      return isNaN(n) ? 0 : n;
    }
    function normalizeCurrency(raw){
      let s = String(raw || 'TL').trim().toUpperCase();
      if (s === 'TRY' || s.includes('TL')) return 'TL';
      if (s === 'USD' || s.includes('DOLAR')) return 'USD';
      if (s === 'EUR' || s.includes('EURO')) return 'EUR';
      if (s === 'GBP' || s.includes('STERLIN')) return 'GBP';
      return s;
    }
    function normalizeRow(row){
      try {
        const tarihRaw = row.tarih ?? row.date ?? row['SÄ°PARÄ°Åž TARÄ°HÄ°'] ?? null;
        const d = parseDate(tarihRaw);
        if (!d) return null;
        const doviz = normalizeCurrency(row.doviz ?? row['DOVÄ°Z CÄ°NSÄ°'] ?? 'TL');
        const nettutarRaw = (
          row.nettutar ??
          row['SÄ°PARÄ°Åž NET TUTAR'] ??
          row['NET TUTAR'] ??
          row['KALAN SÄ°PARÄ°Åž NET TUTAR'] ??
          row.kalannet ??
          row['SÄ°PARÄ°Åž BRÃœT TUTAR'] ??
          row.tutar ??
          row['TUTAR'] ?? 0
        );
        return { tarih: ymd(d), doviz, nettutar: num(nettutarRaw) };
      } catch { return null; }
    }

    // CSV fallback
    function parseCSV(csvText) {
      const lines = csvText.trim().split('\n');
      const headers = lines[0].split(',').map(h => h.trim());
      const data = [];
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line || line.startsWith(',') || !line.includes(',')) continue;
        const values = [];
        let current = '';
        let inQuotes = false;
        for (let j = 0; j < line.length; j++) {
          const char = line[j];
          if (char === '"') { inQuotes = !inQuotes; }
          else if (char === ',' && !inQuotes) { values.push(current.trim()); current = ''; }
          else { current += char; }
        }
        values.push(current.trim());
        if (values.length < headers.length) continue;
        const row = {};
        headers.forEach((header, index) => {
          let value = values[index] ? values[index].trim().replace(/"/g, '') : '';
          if (header.includes('TUTAR') || header.includes('MÄ°KTAR')) {
            value = value.replace(/,/g, '').replace(/\s+/g, '');
            row[header.trim()] = parseFloat(value) || 0;
          } else { row[header.trim()] = value; }
        });
        if (row['SÄ°PARÄ°Åž TARÄ°HÄ°']) {
          const parts = String(row['SÄ°PARÄ°Åž TARÄ°HÄ°']).split('.');
          if (parts.length === 3) { row.date = `${parts[2]}-${pad2(parts[1])}-${pad2(parts[0])}`; }
        }
        data.push(row);
      }
      return data;
    }
    async function getCSVData(){
      try {
        const resp = await fetch('orders.csv', { cache: 'no-store' });
        if (!resp.ok) throw new Error(`CSV yÃ¼klenemedi: ${resp.status}`);
        const text = await resp.text();
        const rows = parseCSV(text);
        console.log(`âœ… CSV'den ${rows.length} kayÄ±t yÃ¼klendi (fallback)`);
        return rows;
      } catch (err) {
        console.error('CSV okuma hatasÄ±:', err);
        return [];
      }
    }

    function sampleData(){
      return [
        { tarih: '2025-08-30T00:00:00', nettutar: 10000, doviz: 'TL' },
        { tarih: '2025-08-31T00:00:00', nettutar: 8200, doviz: 'EUR' },
        { tarih: '2025-09-02T00:00:00', nettutar: 15000, doviz: 'TL' },
        { tarih: '2025-09-03T00:00:00', nettutar: 18000, doviz: 'TL' },
        { tarih: '2025-09-03T00:00:00', nettutar: 11665.2, doviz: 'USD' }
      ];
    }

    async function loadData(){
      const statusDiv = document.getElementById('dataStatus');
      statusDiv.textContent = 'ðŸ“¥ Veriler yÃ¼kleniyor...';

      // 1) IndexedDB
      try {
        const latest = await idbGetLatest();
        if (latest && Array.isArray(latest.data) && latest.data.length) {
          statusDiv.textContent = `âš¡ï¸ IndexedDB: ${latest.data.length} kayÄ±t`; build(latest.data);
        }
      } catch {}
      // 2) localStorage
      const cached = readOrdersCache();
      if (cached && cached.length) {
        statusDiv.textContent = `âš¡ï¸ Cache: ${cached.length} kayÄ±t`; build(cached);
      }
      // 3) API
      try {
        const res = await retryFetch('/api/orders', {}, 2, 15000);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const api = await res.json();
        const rows = api.success ? api.data : Array.isArray(api) ? api : [];
        if (!Array.isArray(rows) || !rows.length) throw new Error('BoÅŸ veri');
        writeOrdersCache(rows); await idbPutLatest(rows);
        statusDiv.textContent = `âœ… API: ${rows.length} kayÄ±t gÃ¼ncellendi`;
        build(rows);
      } catch (e) {
        console.warn('API hatasÄ±, CSV fallback denenecek:', e);
        try {
          const csvRows = await getCSVData();
          if (Array.isArray(csvRows) && csvRows.length) {
            statusDiv.textContent = `âœ… CSV: ${csvRows.length} kayÄ±t yÃ¼klendi`;
            writeOrdersCache(csvRows);
            await idbPutLatest(csvRows);
            build(csvRows);
          } else {
            if (!(cached && cached.length)) { build(sampleData()); statusDiv.textContent = 'âš ï¸ Ã–rnek veriler gÃ¶steriliyor'; }
          }
        } catch (csvErr) {
          console.error('CSV fallback sÄ±rasÄ±nda hata:', csvErr);
          if (!(cached && cached.length)) { build(sampleData()); statusDiv.textContent = 'âš ï¸ Ã–rnek veriler gÃ¶steriliyor'; }
        }
      }
    }

    function build(rows){
      // Normalize
      const normalized = Array.isArray(rows) ? rows.map(normalizeRow).filter(Boolean) : [];

      // GÃ¼n ve ay bazlÄ± toplamlar
      const dayTotals = new Map(); // key: YYYY-MM-DD -> {count, byCurrency}
      const monthTotals = new Map(); // key: YYYY-MM -> {count, byCurrency}
      let maxDate = null;
      for (const r of normalized) {
        const d = parseDate(r.tarih); if (!d) continue; const dayKey = ymd(d), monthKey = ym(d);
        const cur = (r.doviz || 'TL').toUpperCase(); const val = num(r.nettutar) || 0;
        if (!dayTotals.has(dayKey)) dayTotals.set(dayKey, { count:0, byCurrency:{TL:0, USD:0, EUR:0, GBP:0} });
        const dt = dayTotals.get(dayKey); dt.count += 1; dt.byCurrency[cur] = (dt.byCurrency[cur] || 0) + val;
        if (!monthTotals.has(monthKey)) monthTotals.set(monthKey, { count:0, byCurrency:{TL:0, USD:0, EUR:0, GBP:0} });
        const mt = monthTotals.get(monthKey); mt.count += 1; mt.byCurrency[cur] = (mt.byCurrency[cur] || 0) + val;
        if (!maxDate || d > maxDate) maxDate = d;
      }
      if (!maxDate) return;

      // GÃ¼nlÃ¼k karÅŸÄ±laÅŸtÄ±rma (USD/EUR)
      const latestKey = ymd(maxDate);
      const prevKey = ymd(addDays(maxDate, -1));
      const latestUSD = (dayTotals.get(latestKey)?.byCurrency?.USD) || 0;
      const prevUSD = (dayTotals.get(prevKey)?.byCurrency?.USD) || 0;
      const dDeltaUSD = latestUSD - prevUSD;
      const dPctUSD = prevUSD ? (dDeltaUSD / prevUSD) * 100 : (latestUSD ? 100 : 0);
      document.getElementById('dailyLatestUSD').textContent = '$ ' + fmtMoney(latestUSD);
      document.getElementById('dailyPrevUSD').textContent = '$ ' + fmtMoney(prevUSD);
      document.getElementById('dailyDeltaUSD').textContent = (dDeltaUSD >= 0 ? '+$ ' : '$ ') + fmtMoney(dDeltaUSD);
      const dPctUSDEl = document.getElementById('dailyDeltaUSDPct'); dPctUSDEl.textContent = `${(dPctUSD).toFixed(1)}%`; dPctUSDEl.className = 'delta ' + (dDeltaUSD >= 0 ? 'up' : 'down');

      const latestEUR = (dayTotals.get(latestKey)?.byCurrency?.EUR) || 0;
      const prevEUR = (dayTotals.get(prevKey)?.byCurrency?.EUR) || 0;
      const dDeltaEUR = latestEUR - prevEUR;
      const dPctEUR = prevEUR ? (dDeltaEUR / prevEUR) * 100 : (latestEUR ? 100 : 0);
      document.getElementById('dailyLatestEUR').textContent = 'â‚¬ ' + fmtMoney(latestEUR);
      document.getElementById('dailyPrevEUR').textContent = 'â‚¬ ' + fmtMoney(prevEUR);
      document.getElementById('dailyDeltaEUR').textContent = (dDeltaEUR >= 0 ? '+â‚¬ ' : 'â‚¬ ') + fmtMoney(dDeltaEUR);
      const dPctEUREl = document.getElementById('dailyDeltaEURPct'); dPctEUREl.textContent = `${(dPctEUR).toFixed(1)}%`; dPctEUREl.className = 'delta ' + (dDeltaEUR >= 0 ? 'up' : 'down');

      // GÃ¼nlÃ¼k snapshotlarÄ± IndexedDB 'days' store'a yaz
      (async ()=>{
        try {
          const latestTotals = dayTotals.get(latestKey);
          if (latestTotals) {
            await idbPutDay(latestKey, { count: latestTotals.count, byCurrency: latestTotals.byCurrency });
          }
          const prevTotals = dayTotals.get(prevKey);
          if (prevTotals) {
            const existingPrev = await idbGetDay(prevKey);
            if (!existingPrev) {
              await idbPutDay(prevKey, { count: prevTotals.count, byCurrency: prevTotals.byCurrency });
            }
          }
        } catch (e) { console.warn('GÃ¼nlÃ¼k snapshot yazma hatasÄ±', e); }
      })();

      // AylÄ±k karÅŸÄ±laÅŸtÄ±rma (USD/EUR)
      const nowMonthKey = ym(maxDate);
      const prevMonthDate = new Date(maxDate.getFullYear(), maxDate.getMonth()-1, 1);
      const prevMonthKey = ym(prevMonthDate);
      const nowUSD = (monthTotals.get(nowMonthKey)?.byCurrency?.USD) || 0;
      const prevUSDm = (monthTotals.get(prevMonthKey)?.byCurrency?.USD) || 0;
      const mDeltaUSD = nowUSD - prevUSDm;
      const mPctUSD = prevUSDm ? (mDeltaUSD / prevUSDm) * 100 : (nowUSD ? 100 : 0);
      document.getElementById('monthNowUSD').textContent = '$ ' + fmtMoney(nowUSD);
      document.getElementById('monthPrevUSD').textContent = '$ ' + fmtMoney(prevUSDm);
      document.getElementById('monthDeltaUSD').textContent = (mDeltaUSD >= 0 ? '+$ ' : '$ ') + fmtMoney(mDeltaUSD);
      const mPctUSDEl = document.getElementById('monthDeltaUSDPct'); mPctUSDEl.textContent = `${(mPctUSD).toFixed(1)}%`; mPctUSDEl.className = 'delta ' + (mDeltaUSD >= 0 ? 'up' : 'down');

      const nowEUR = (monthTotals.get(nowMonthKey)?.byCurrency?.EUR) || 0;
      const prevEURm = (monthTotals.get(prevMonthKey)?.byCurrency?.EUR) || 0;
      const mDeltaEUR = nowEUR - prevEURm;
      const mPctEUR = prevEURm ? (mDeltaEUR / prevEURm) * 100 : (nowEUR ? 100 : 0);
      document.getElementById('monthNowEUR').textContent = 'â‚¬ ' + fmtMoney(nowEUR);
      document.getElementById('monthPrevEUR').textContent = 'â‚¬ ' + fmtMoney(prevEURm);
      document.getElementById('monthDeltaEUR').textContent = (mDeltaEUR >= 0 ? '+â‚¬ ' : 'â‚¬ ') + fmtMoney(mDeltaEUR);
      const mPctEUREl = document.getElementById('monthDeltaEURPct'); mPctEUREl.textContent = `${(mPctEUR).toFixed(1)}%`; mPctEUREl.className = 'delta ' + (mDeltaEUR >= 0 ? 'up' : 'down');

      renderMonthlyChart(monthTotals);
      renderMonthlyTable(monthTotals);

      // Durum satÄ±rÄ±na tanÄ± amaÃ§lÄ± Ã¶zet ekle (gizli debug)
      try {
        const statusDiv = document.getElementById('dataStatus');
        const latestTotals = dayTotals.get(latestKey) || { byCurrency: {} };
        const monthTotalsNow = monthTotals.get(nowMonthKey) || { byCurrency: {} };
        const dbg = `GÃ¼n TL:${fmtMoney(latestTotals.byCurrency.TL||0)} USD:${fmtMoney(latestTotals.byCurrency.USD||0)} EUR:${fmtMoney(latestTotals.byCurrency.EUR||0)} | Ay TL:${fmtMoney(monthTotalsNow.byCurrency.TL||0)} USD:${fmtMoney(monthTotalsNow.byCurrency.USD||0)} EUR:${fmtMoney(monthTotalsNow.byCurrency.EUR||0)}`;
        statusDiv.textContent = `${statusDiv.textContent} â€¢ ${dbg}`;
      } catch {}
    }

    function renderMonthlyChart(monthTotals){
      const months = Array.from(monthTotals.keys()).sort();
      const tlValues = months.map(m => (monthTotals.get(m)?.byCurrency?.TL) || 0);
      const trace = { x: months, y: tlValues, type: 'bar', marker: { color: '#89b4fa' } };
      const layout = {
        paper_bgcolor: '#1a1d29', plot_bgcolor: '#1a1d29',
        xaxis: { title: 'Ay', color: '#cdd6f4', gridcolor: '#313244' },
        yaxis: { title: 'Toplam (TL)', color: '#cdd6f4', gridcolor: '#313244', tickformat: ',.0f' },
        margin: { l: 60, r: 20, t: 30, b: 40 }, font: { color: '#cdd6f4' }, height: 360
      };
      const el = document.getElementById('monthlyChart');
      if (window.Plotly && window.Plotly.newPlot) { window.Plotly.newPlot(el, [trace], layout); }
    }

    function renderMonthlyTable(monthTotals){
      const tbody = document.getElementById('monthlyTableBody');
      tbody.innerHTML = '';
      const months = Array.from(monthTotals.keys()).sort();
      const prevTLByMonth = {}; months.forEach((m, i) => { const prev = months[i-1]; prevTLByMonth[m] = prev ? (monthTotals.get(prev)?.byCurrency?.TL || 0) : 0; });
      months.forEach(m => {
        const mt = monthTotals.get(m);
        const tl = mt.byCurrency.TL || 0; const usd = mt.byCurrency.USD || 0; const eur = mt.byCurrency.EUR || 0;
        const prevTL = prevTLByMonth[m] || 0; const pct = prevTL ? ((tl - prevTL) / prevTL) * 100 : (tl ? 100 : 0);
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${m}</td>
          <td>${mt.count}</td>
          <td>â‚º ${fmtMoney(tl)}</td>
          <td>$ ${fmtMoney(usd)}</td>
          <td>â‚¬ ${fmtMoney(eur)}</td>
          <td>${pct.toFixed(1)}%</td>
        `;
        tbody.appendChild(tr);
      });
    }

    document.addEventListener('DOMContentLoaded', async () => { startHeaderClock(); await ensurePersistence(); loadData(); });
  </script>
</body>
</html>